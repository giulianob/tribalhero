#region

using System;
using System.Collections.Generic;
using System.Linq;
using Game.Battle;
using Game.Battle.CombatGroups;
using Game.Battle.CombatObjects;
using Game.Data;
using Game.Data.Troop;
using Game.Setup;
using Game.Util;

#endregion

namespace Game.Logic.Procedures
{
    public class BattleProcedure
    {
        private readonly ICombatGroupFactory combatGroupFactory;

        private readonly ICombatUnitFactory combatUnitFactory;

        [Obsolete("For testing only", true)]
        protected BattleProcedure()
        {
        }

        public BattleProcedure(ICombatUnitFactory combatUnitFactory,
                               ICombatGroupFactory combatGroupFactory)
        {
            this.combatUnitFactory = combatUnitFactory;
            this.combatGroupFactory = combatGroupFactory;            
        }
        
        // TODO: Change to instance method.. need to make sure City is being created by ninject first though
        public static bool IsNewbieProtected(IPlayer player)
        {
            return SystemClock.Now.Subtract(player.Created).TotalSeconds < Config.newbie_protection;
        }

<<<<<<< local
        public virtual ICombatGroup AddAttackerToBattle(IBattleManager battleManager, ITroopObject troopObject)
=======
        public virtual Error CanCityBeAttacked(ICity attackerCity, ICity targetCity)
        {
            // Can't attack tribes mate
            if (attackerCity.Owner.Tribesman != null && targetCity.Owner.Tribesman != null &&
                attackerCity.Owner.Tribesman.Tribe == targetCity.Owner.Tribesman.Tribe)
            {
                return Error.AssignmentCantAttackFriend;
            }

            // Can't attack if target is under newbie protection
            if (IsNewbieProtected(targetCity.Owner))
            {
                return Error.PlayerNewbieProtection;
            }

            // Can't attack cities that are being deleted
            if (targetCity.Deleted != City.DeletedState.NotDeleted)
            {
                return Error.ObjectNotAttackable;
            }

            return Error.Ok;
        }

        public virtual Error CanStructureBeAttacked(IStructure structure)
        {
            if (structure.IsBlocked || structure.Stats.Hp == 0)
            {
                return Error.ObjectNotAttackable;
            }

            // Can't attack structures that are being built
            if (structure.Lvl == 0)
            {
                return Error.ObjectNotAttackable;
            }

            // Can't attack structures that are marked as Unattackable
            if (objectTypeFactory.IsStructureType("Unattackable", structure))
            {
                return Error.ObjectNotAttackable;
            }

            // Can't attack understroyabled structure that are level 1
            if ((objectTypeFactory.IsStructureType("Undestroyable", structure) && structure.Lvl <= 1))
            {
                return Error.StructureUndestroyable;
            }

            return Error.Ok;
        }

        public virtual void MoveUnitFormation(ITroopStub stub, FormationType source, FormationType target)
        {
            stub[target].Add(stub[source]);
            stub[source].Clear();
        }

        protected virtual void AddLocalStructuresToBattle(IBattleManager battleManager,
                                                          ICity targetCity,
                                                          ITroopObject attackerTroopObject)
        {
            var localGroup = GetOrCreateLocalGroup(targetCity.Battle, targetCity);
            foreach (IStructure structure in
                    GetStructuresInRadius(targetCity, attackerTroopObject)
                            .Where(structure => structure.State.Type == ObjectState.Normal && CanStructureBeAttacked(structure) == Error.Ok))
            {
                structure.BeginUpdate();
                structure.State = GameObjectState.BattleState(battleManager.BattleId);
                structure.EndUpdate();

                localGroup.Add(combatUnitFactory.CreateStructureCombatUnit(battleManager, structure));
            }
        }

        public virtual void AddLocalUnitsToBattle(IBattleManager battleManager, ICity city)
        {
            if (city.DefaultTroop[FormationType.Normal].Count == 0)
            {
                return;
            }

            // Move to in battle formation
            var unitsToJoinBattle = city.DefaultTroop[FormationType.Normal].ToList();
            city.DefaultTroop.BeginUpdate();
            city.DefaultTroop.State = TroopState.Battle;
            city.DefaultTroop.Template.LoadStats(TroopBattleGroup.Local);
            MoveUnitFormation(city.DefaultTroop, FormationType.Normal, FormationType.InBattle);
            city.DefaultTroop.EndUpdate();

            // Add to local group
            var combatGroup = GetOrCreateLocalGroup(battleManager, city);
            foreach (KeyValuePair<ushort, ushort> kvp in unitsToJoinBattle)
            {
                var defenseCombatUnits = combatUnitFactory.CreateDefenseCombatUnit(battleManager, city.DefaultTroop, FormationType.InBattle, kvp.Key, kvp.Value);
                defenseCombatUnits.ToList().ForEach(combatGroup.Add);
            }
        }

        protected virtual ICombatGroup AddAttackerToBattle(IBattleManager battleManager, ITroopObject troopObject)
>>>>>>> other
        {
            var offensiveGroup = combatGroupFactory.CreateCityOffensiveCombatGroup(battleManager.BattleId,
                                                                                   battleManager.GetNextGroupId(),
                                                                                   troopObject);
            foreach (
                    var attackCombatUnits in
                            troopObject.Stub.SelectMany(formation => formation)
                                       .Select(
                                               kvp =>
                                               combatUnitFactory.CreateAttackCombatUnit(battleManager,
                                                                                        troopObject,
                                                                                        FormationType.Attack,
                                                                                        kvp.Key,
                                                                                        kvp.Value)))
            {
                attackCombatUnits.ToList().ForEach(offensiveGroup.Add);
            }

            battleManager.Add(offensiveGroup, BattleManager.BattleSide.Attack, true);

            return offensiveGroup;
        }

        public virtual uint AddReinforcementToBattle(IBattleManager battleManager, ITroopStub stub, FormationType formationToAddToBattle)
        {
            stub.BeginUpdate();
            stub.Template.LoadStats(TroopBattleGroup.Defense);
            stub.EndUpdate();

            var defensiveGroup = combatGroupFactory.CreateCityDefensiveCombatGroup(battleManager.BattleId,
                                                                                   battleManager.GetNextGroupId(),
                                                                                   stub);
            foreach (var kvp in stub[formationToAddToBattle])
            {
                combatUnitFactory.CreateDefenseCombatUnit(battleManager, stub, formationToAddToBattle, kvp.Key, kvp.Value)
                                 .ToList()
                                 .ForEach(defensiveGroup.Add);
            }
            battleManager.Add(defensiveGroup, BattleManager.BattleSide.Defense, true);

            return defensiveGroup.Id;
        }

        /// <summary>
        ///     Repairs all structures up to max HP but depends on percentage from sense of urgency effect
        /// </summary>
        /// <param name="city"></param>
        /// <param name="maxHp"></param>
        internal virtual void SenseOfUrgency(ICity city, uint maxHp)
        {
            // Prevent overflow, just to be safe
            maxHp = Math.Min(50000, maxHp);

            int healPercent = Math.Min(100,
                                       city.Technologies.GetEffects(EffectCode.SenseOfUrgency).Sum(x => (int)x.Value[0]));

            if (healPercent == 0)
            {
                return;
            }

            ushort restore = (ushort)(maxHp * (healPercent / 100f));

            foreach (
                    IStructure structure in
                            city.Where(
                                       structure =>
                                       structure.State.Type != ObjectState.Battle &&
                                       structure.Stats.Hp != structure.Stats.Base.Battle.MaxHp))
            {
                structure.BeginUpdate();
                structure.Stats.Hp += restore;
                structure.EndUpdate();
            }
        }

        public virtual bool HasTooManyAttacks(ICity city)
        {
            return city.Worker.PassiveActions.Values.Count(action => action.Category == ActionCategory.Attack) > 20;
        }

        public virtual bool HasTooManyDefenses(ICity city)
        {
            return city.Worker.PassiveActions.Values.Count(action => action.Category == ActionCategory.Defense) > 20;
        }
    }
}